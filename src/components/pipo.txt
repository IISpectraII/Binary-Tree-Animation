draw(type, r) {

        const example = d3.select(this.refs.example),
            width = d3.getSize(example.style('width')),
            height = Math.min(500, width);

        x = d3.scaleLinear().range([0, width]);
        y = d3.scaleLinear().range([0, height]);

        example.select(this.refs.paper).remove();

        paper = example
                .append(type)
                .classed('paper', true)
                .attr('width', width).attr('height', height).canvasResolution(r).canvas(true);

        paper.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', '#fff');

        text = paper.append('g').append('text')
            .text('Depth: 0')
            .style('font-size', '20px')
            .style('text-anchor', 'middle')
            .style('alignment-baseline', 'middle')
            .attr("transform", "translate(50, 50)");

        paper.append('g').classed('links', true).style("stroke-width", "0.5px");
        paper.append('g').classed('tree', true);

        circle = paper
                    .append('g')
                    .classed('node', true)
                    .append('circle')
                    .attr("r", 1.5*radius)
                    .style("stroke", "black")
                    .style("fill", "yellow");

        updateTree();
    }

    tick () {
        if (pnodes) {
            plinks
                .attr("x1", function (d) {return x(d.source.x);})
                .attr("y1", function (d) {return y(d.source.y);})
                .attr("x2", function (d) {return x(d.target.x);})
                .attr("y2", function (d) {return y(d.target.y);});
            pnodes
                .attr("cx", function (d) {return x(d.x);})
                .attr("cy", function (d) {return y(d.y);});
        }
    }

    insertAnimation (node, tree) {
        var self = this;
        node.x = self.x;
        node.y = self.y;
        updateNode();

        d3.timeout(function () {
            if (node.score > self.score) {
                if (self.right) return insertAnimation.call(self.right, node, tree);
            } else {
                if (self.left) return insertAnimation.call(self.left, node, tree);
            }
            tree.root = self.insert(node, function (nd) {
                d3.timeout(function () {
                    addNode(nd);
                });
            });
        }, 50);
    }

    updateTree () {
        var circles = paper.select('g.tree').selectAll('circle')
                    .data(simulation.nodes()),
            lines = paper.select('g.links').selectAll('line')
                    .data(simulation.force('links').links());

        plinks = lines
            .enter()
            .append("line")
            .style("stroke", "black")
            .merge(lines);

        pnodes = circles
            .enter()
            .append("circle")
            .attr("r", radius)
            .style("stroke", "black")
            .merge(circles)
            .style("fill", function (d) {return d.red ? "red" : "black";});
    }

    addNode (nd) {
        var nodes = simulation.nodes(),
            links = simulation.force('links');
        resetNode();
        if (nd.parent) {
            nd.x = nd.parent.x;
            nd.y = nd.parent.y;
        }
        maxDepth = tree.maxDepth();
        treeSize = tree.size();
        text.text('Depth: ' + maxDepth);
        nodes.push(nd);
        simulation.nodes(nodes);
        links.links(tree.links());
        updateTree();
        dropNode();
        simulation.alphaTarget(0.3).restart();
    }

    dropNode () {
        if (!node.x) resetNode();
        var target = tree.root ? tree.root.y : 0.5;
        node.y += 0.01;
        if (node.y >= target)
            tree.insert(node);
        else {
            updateNode();
            d3.timeout(dropNode, 10);
        }
    }

    resetNode() {
        node.x = 0.5;
        node.y = -0.15;
        node.score = generator();
    }

    updateNode () {
        circle
            .attr("cx", x(node.x))
            .attr("cy", y(node.y))
    }